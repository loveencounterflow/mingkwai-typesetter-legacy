// Generated by CoffeeScript 1.8.0
(function() {
  var Htmlparser, P1, RMY, TEXT, TRM, TYPES, XNCHR, alert, badge, debug, echo, help, info, njs_fs, njs_path, rpr, urge, verbose, warn, whisper,
    __modulo = function(a, b) { return (+a % (b = +b) + b) % b; },
    __slice = [].slice;

  njs_path = require('path');

  njs_fs = require('fs');

  TEXT = require('coffeenode-text');

  TYPES = require('coffeenode-types');

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'TYPESETTER';

  info = TRM.get_logger('info', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  urge = TRM.get_logger('urge', badge);

  whisper = TRM.get_logger('whisper', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  RMY = require('remarkably');

  Htmlparser = (require('htmlparser2')).Parser;

  XNCHR = require('./XNCHR');

  P1 = require('pipedreams');

  verbose = true;

  verbose = false;

  this.new_document = function(settings) {
    var R, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
    if (settings == null) {
      settings = {};
    }
    R = {
      '~isa': 'MINGKWAI/TYPESETTER/document',
      cells: [],
      idx: -1,
      size: 1
    };
    R['keep_x_grid'] = (_ref = settings['keep_x_grid']) != null ? _ref : false;
    R['cells_per_line'] = (_ref1 = settings['cells-per-line']) != null ? _ref1 : 8;
    R['lines_per_page'] = (_ref2 = settings['lines-per-page']) != null ? _ref2 : 6;
    R['auto_space_chr'] = (_ref3 = settings['auto-space-chr']) != null ? _ref3 : '\u3000';
    R['blockade_chr'] = (_ref4 = settings['blockade-chr']) != null ? _ref4 : '＃';
    R['free_cell_chr'] = (_ref5 = settings['free-cell-chr']) != null ? _ref5 : '〇';
    R['layout'] = (_ref6 = settings['layout']) != null ? _ref6 : 'rows';
    R['direction'] = (_ref7 = settings['direction']) != null ? _ref7 : 'ltr';
    if (R['keep_x_grid']) {
      throw new Error("`keep_x_grid` not implemented");
    }
    return R;
  };

  this.new_observable_document = function(settings, handler) {
    var R, arity, get_observer, _ref;
    require('harmony-reflect');
    switch (arity = arguments.length) {
      case 1:
        _ref = [null, settings], settings = _ref[0], handler = _ref[1];
        break;
      case 2:
        null;
        break;
      default:
        throw new Error("expect 2 arguments, got " + arity);
    }
    get_observer = function(observee_name) {
      var S;
      S = {
        get: function(target, name) {
          var value;
          value = target[name];
          handler(observee_name, 'get', target, name);
          return value;
        },
        set: function(target, name, value) {
          target[name] = value;
          handler(observee_name, 'set', target, name, value);
          return value;
        }
      };
      return S;
    };
    R = this.new_document(settings);
    return Proxy(R, get_observer('doc'));
  };

  this._new_block = function(me, content) {
    var R, size;
    size = me.size;
    if (size === 1) {
      return content;
    }
    R = {
      '~isa': 'MINGKWAI/TYPESETTER/block',
      size: size,
      content: content
    };
    return R;
  };

  this.blockade = {
    '~isa': 'MINGKWAI/TYPESETTER/blockade'
  };

  this._get = function(me, pos, fallback) {
    var R, idx;
    idx = this.idx_from_pos(me, pos);
    R = me['cells'][idx];
    if (R === void 0) {
      if (arguments.length > 2) {
        return fallback;
      }
      throw new Error("position " + (this._rpr_pos(me, pos)) + " out of bounds");
    }
    return R;
  };

  this._set = function(me, pos, content) {
    var idx, size, xy;
    idx = this.idx_from_pos(me, pos);
    xy = this.xy_from_pos(me, pos);
    size = me.size;
    this._validate_xy(me, xy, size);
    me['cells'][idx] = content;
    return me;
  };

  this.put = function(me, content) {

    /* TAINT `put` doesn't honor `size` */
    var blockade_chr, cells, dx, dy, idx, size, x0, y0, _i, _j, _ref;
    this.advance_chr(me);
    idx = me.idx, size = me.size, cells = me.cells, blockade_chr = me.blockade_chr;
    _ref = this._get_xy(me), x0 = _ref[0], y0 = _ref[1];
    this._set(me, idx, this._new_block(me, content));
    for (dx = _i = 0; 0 <= size ? _i < size : _i > size; dx = 0 <= size ? ++_i : --_i) {
      for (dy = _j = 0; 0 <= size ? _j < size : _j > size; dy = 0 <= size ? ++_j : --_j) {
        if ((dx === dy && dy === 0)) {
          continue;
        }
        cells[this.idx_from_xy(me, [x0 + dx, y0 + dy])] = this.blockade;
      }
    }
    return me;
  };


  /*
   *===========================================================================================================
  
  
  
         d8888 8888888b.  888     888        d8888 888b    888  .d8888b.  8888888888
        d88888 888  "Y88b 888     888       d88888 8888b   888 d88P  Y88b 888
       d88P888 888    888 888     888      d88P888 88888b  888 888    888 888
      d88P 888 888    888 Y88b   d88P     d88P 888 888Y88b 888 888        8888888
     d88P  888 888    888  Y88b d88P     d88P  888 888 Y88b888 888        888
    d88P   888 888    888   Y88o88P     d88P   888 888  Y88888 888    888 888
   d8888888888 888  .d88P    Y888P     d8888888888 888   Y8888 Y88b  d88P 888
  d88P     888 8888888P"      Y8P     d88P     888 888    Y888  "Y8888P"  8888888888
  
  
  
   *===========================================================================================================
   */

  this.advance_line = function(me, size) {
    if (size == null) {
      size = null;
    }
    return this._advance(me, 'line', size);
  };

  this.advance_page = function(me, size) {
    if (size == null) {
      size = null;
    }
    return this._advance(me, 'page', size);
  };

  this._advance = function(me, mode, size) {
    var idx, last_x, last_y, p, p1, x, y, y1, _ref;
    idx = me.idx;
    if (idx < 0) {
      return me;
    }
    if (size == null) {
      size = me['size'];
    }
    switch (mode) {
      case 'line':
        y1 = (this._get_grid_line_ys(me, this._get_y(me), size))[1];
        break;
      case 'page':
        p1 = this._get_page_idx(me);
        break;
      default:
        throw new Error("unknown mode " + (rpr(mode)));
    }
    last_x = null;
    last_y = null;
    while (true) {
      _ref = this._get_xy(me), x = _ref[0], y = _ref[1];
      if (mode === 'line') {
        if (y > y1) {
          break;
        }
      } else {
        p = (this.pcr_from_xy(me, [x, y]))[0];
        if (p > p1) {
          break;
        }
      }
      last_x = x;
      last_y = y;
      this.advance_chr(me);
    }
    me['idx'] = this.idx_from_xy(me, [last_x, last_y]);
    return me;
  };

  this.advance_chr = function(me) {
    var cell_is_free, cells, enough_free_cells, idx, on_grid_line, size;
    size = me.size, cells = me.cells, idx = me.idx;
    if (idx < 0) {
      me['idx'] = 0;
      return me;
    }

    /* If character size is 1, we can simply advance to the next cell. Since it is not allowed to
      retroactively change cell contents, this should always put on a free cell.
     */
    if (size === 1) {
      while (true) {
        me['idx'] += 1;
        cell_is_free = cells[me['idx']] === void 0;
        if (cell_is_free) {
          break;
        }
      }
      return me;
    }

    /* If character size `s` is greater than 1, we must advance to a position on a line that has both an
      integer multiple of `s` free cells left and that is a multiple integer (including 0) of `s` lines from
      the top. We go step by step, filling up blank cells with `auto_space_chr`.
     */
    while (true) {
      me['idx'] += 1;
      enough_free_cells = (this._get_remaining_line_length(me)) >= 1;
      on_grid_line = (__modulo(this._get_y(me), size)) === 0;
      cell_is_free = cells[me['idx']] === void 0;
      if (enough_free_cells && on_grid_line && cell_is_free) {
        break;
      }
      if (cell_is_free) {
        me['cells'][me['idx']] = me['auto_space_chr'];
      }
    }
    return me;
  };


  /*
   *===========================================================================================================
  
  
  
   .d8888b.   .d88888b.  888b     d888 8888888b.  8888888b.  8888888888  .d8888b.   .d8888b.
  d88P  Y88b d88P" "Y88b 8888b   d8888 888   Y88b 888   Y88b 888        d88P  Y88b d88P  Y88b
  888    888 888     888 88888b.d88888 888    888 888    888 888        Y88b.      Y88b.
  888        888     888 888Y88888P888 888   d88P 888   d88P 8888888     "Y888b.    "Y888b.
  888        888     888 888 Y888P 888 8888888P"  8888888P"  888            "Y88b.     "Y88b.
  888    888 888     888 888  Y8P  888 888        888 T88b   888              "888       "888
  Y88b  d88P Y88b. .d88P 888   "   888 888        888  T88b  888        Y88b  d88P Y88b  d88P
   "Y8888P"   "Y88888P"  888       888 888        888   T88b 8888888888  "Y8888P"   "Y8888P"
  
  
  
   *===========================================================================================================
   */

  this.set_size = function(me, size) {
    if (size !== 1 && size !== 2 && size !== 3 && size !== 4) {
      throw new Error("unsupported size " + (rpr(size)));
    }
    me['size'] = size;
    return me;
  };

  this.size_of = function(me, pos) {
    var cell, type;
    cell = me['cells'][this.idx_from_pos(me, pos)];

    /* TAINT it could be argued that the size of any blockaded cell is the size of the block that caused the
      blackade
     */
    switch (type = TYPES.type_of(cell)) {
      case 'text':
        return 1;
      case 'MINGKWAI/TYPESETTER/block':
        return cell['size'];
      default:
        throw new Error("unable to determine size for cell of type " + (rpr(type)));
    }
  };

  this.compress = function(me) {
    var auto_space_chr, blank_count, blockade_chr, cell, cell_count, cells, cells_per_line, chr_count, d, doc_idx, doc_x, doc_y, dx, dy, height, idx, idx0, idx1, size, tmp_cell, tmp_cells, tmp_cells_per_line, tmp_idx, width, x, x0, x1, y, y0, y1, _i, _j, _k, _l, _len, _ref, _ref1, _ref2;
    size = me.size, idx = me.idx, cells = me.cells, cells_per_line = me.cells_per_line, blockade_chr = me.blockade_chr, auto_space_chr = me.auto_space_chr;
    if (size === 1) {
      throw new Error("unsupported size " + (rpr(size)) + " for compress");
    }

    /* Don't do anything if we're at the start of the document: */
    if (idx < 0) {
      return me;
    }
    if (cells[idx] === void 0) {
      return me;
    }

    /* Don't do anything if the current character isn't a size 1 character: */
    if ((this.size_of(me, idx)) !== 1) {
      return me;
    }

    /* Find top and bottom boundaries. */
    _ref = this.xy_from_idx(me, idx), x = _ref[0], y = _ref[1];
    _ref1 = this._get_grid_line_ys(me, y, size), y0 = _ref1[0], y1 = _ref1[1];

    /* Find left and right boundaries. */

    /* If we're on the first line of the compressible region, we're already behind the last compressible
      position; if we're on any following line, the first line must be full, so `x1` is the line cellcount
      minus one:
     */
    x1 = y === y0 ? x : cells_per_line - 1;

    /* Since we don't support ragged left borders, all lines must start at the same index `x0`. */
    x0 = x;
    while (true) {

      /* Walking leftwards until we're at the margin or see a blocking signal to the left: */
      if (x0 === 0) {
        break;
      }
      if ((this._get(me, [x0 - 1, y0])) === this.blockade) {
        break;
      }
      x0 -= 1;
    }
    width = x1 - x0 + 1;
    height = size;
    chr_count = (Math.max(0, y - y0)) * width + (x - x0 + 1);
    blank_count = __modulo(chr_count, height);
    if (blank_count > 0) {
      blank_count = height - blank_count;
    }
    cell_count = chr_count + blank_count;
    idx0 = this.idx_from_xy(me, [x0, y0]);
    tmp_cells_per_line = cell_count / height;
    tmp_cells = [];
    for (doc_y = _i = y0; y0 <= y1 ? _i <= y1 : _i >= y1; doc_y = y0 <= y1 ? ++_i : --_i) {
      for (doc_x = _j = x0; x0 <= x1 ? _j <= x1 : _j >= x1; doc_x = x0 <= x1 ? ++_j : --_j) {
        doc_idx = this.idx_from_xy(me, [doc_x, doc_y]);
        cell = cells[doc_idx];
        if (cell != null) {
          tmp_cells.push(cell);
        }
        cells[doc_idx] = void 0;
      }
    }
    for (d = _k = 0; 0 <= blank_count ? _k < blank_count : _k > blank_count; d = 0 <= blank_count ? ++_k : --_k) {
      tmp_cells.push(auto_space_chr);
    }
    me['idx'] = idx0 + tmp_cells_per_line - 1;
    for (tmp_idx = _l = 0, _len = tmp_cells.length; _l < _len; tmp_idx = ++_l) {
      tmp_cell = tmp_cells[tmp_idx];
      _ref2 = this.xy_from_idx(null, tmp_idx, tmp_cells_per_line), dx = _ref2[0], dy = _ref2[1];
      idx1 = this.idx_from_xy(me, [x0 + dx, y0 + dy]);
      cells[idx1] = tmp_cell;
    }
    return me;
  };


  /*
   *===========================================================================================================
  
  
  
   .d8888b.   .d88888b.   .d88888b.  8888888b.  8888888b.  8888888 888b    888        d8888 88888888888 8888888888  .d8888b.
  d88P  Y88b d88P" "Y88b d88P" "Y88b 888   Y88b 888  "Y88b   888   8888b   888       d88888     888     888        d88P  Y88b
  888    888 888     888 888     888 888    888 888    888   888   88888b  888      d88P888     888     888        Y88b.
  888        888     888 888     888 888   d88P 888    888   888   888Y88b 888     d88P 888     888     8888888     "Y888b.
  888        888     888 888     888 8888888P"  888    888   888   888 Y88b888    d88P  888     888     888            "Y88b.
  888    888 888     888 888     888 888 T88b   888    888   888   888  Y88888   d88P   888     888     888              "888
  Y88b  d88P Y88b. .d88P Y88b. .d88P 888  T88b  888  .d88P   888   888   Y8888  d8888888888     888     888        Y88b  d88P
   "Y8888P"   "Y88888P"   "Y88888P"  888   T88b 8888888P"  8888888 888    Y888 d88P     888     888     8888888888  "Y8888P"
  
  
  
   *===========================================================================================================
   */

  this.idx_from_xy = function(me, xy, allow_wrap) {
    var cells_per_line, lines_per_page, x, y;
    if (allow_wrap == null) {
      allow_wrap = false;
    }
    if (allow_wrap) {
      throw new Error("wrapping not implemented");
    }
    cells_per_line = me.cells_per_line, lines_per_page = me.lines_per_page;
    x = xy[0], y = xy[1];
    if (!(x < cells_per_line)) {
      throw Error("illegal x " + (rpr(x)));
    }
    return y * cells_per_line + x;
  };

  this.xy_from_idx = function(me, idx, cells_per_line) {
    if (cells_per_line == null) {
      cells_per_line = me['cells_per_line'];
    }
    return [__modulo(idx, cells_per_line), Math.floor(idx / cells_per_line)];
  };

  this.idx_from_pos = function(me, pos) {
    if (TYPES.isa_number(pos)) {
      return pos;
    }
    return this.idx_from_xy(me, pos);
  };

  this.xy_from_pos = function(me, pos) {
    if (TYPES.isa_list(pos)) {
      return pos;
    }
    return this.xy_from_idx(me, pos);
  };

  this.pcr_from_xy = function(me, xy, size) {
    var cells_per_line, col, direction, layout, lines_per_page, page_idx, row, width, x, y, _ref, _ref1;
    if (size == null) {
      size = 1;
    }
    cells_per_line = me.cells_per_line, lines_per_page = me.lines_per_page, layout = me.layout, direction = me.direction;
    x = xy[0], y = xy[1];
    page_idx = Math.floor(y / lines_per_page);
    y = __modulo(y, lines_per_page);
    if (layout === 'rows') {
      _ref = [x, y], col = _ref[0], row = _ref[1];
      width = cells_per_line;
    } else {
      _ref1 = [y, x], col = _ref1[0], row = _ref1[1];
      width = lines_per_page;
    }
    if (direction === 'rtl') {
      col = width - col - (size - 1);
    }
    return [page_idx, col, row];
  };

  this.get_next_idx = function(me) {
    return me['cells'].length;
  };

  this.get_next_xy = function(me, pos) {
    return this.xy_from_idx(me, this.get_next_idx(me));
  };

  this._validate_xy = function(me, xy, size) {
    var keep_x_grid, old_content, x, y;
    keep_x_grid = me.keep_x_grid;
    x = xy[0], y = xy[1];
    if (keep_x_grid && size > 1) {
      if (__modulo(x, size) !== 0) {
        throw new Error("" + (this._rpr_xy(me, xy)) + " not within x grid size " + size);
      }
    }
    if (__modulo(y, size) !== 0) {
      throw new Error("" + (this._rpr_xy(me, xy)) + " not within y grid size " + size);
    }
    old_content = me['cells'][this.idx_from_xy(me, xy)];
    if (old_content !== void 0) {
      throw new Error("cannot overwrite " + (this._rpr_xy(me, xy)) + " " + (rpr(old_content)));
    }
    return me;
  };

  this._rpr_pos = function(me, pos) {
    if (TYPES.isa_number(pos)) {
      return this._rpr_idx(me, pos);
    } else {
      return this._rpr_xy(me, pos);
    }
  };

  this._rpr_xy = function(me, xy) {
    return "( x:" + xy[0] + ", y:" + xy[1] + " )";
  };

  this._rpr_idx = function(me, idx) {
    return this._rpr_xy(me, this.xy_from_pos(me, idx));
  };

  this._get_idx = function(me) {
    return me['idx'];
  };

  this._get_xy = function(me) {
    return this.xy_from_idx(me, me['idx']);
  };

  this._get_x = function(me) {
    return (this._get_xy(me))[0];
  };

  this._get_y = function(me) {
    return (this._get_xy(me))[1];
  };

  this._get_page_idx = function(me) {
    return (this.pcr_from_xy(me, this._get_xy(me)))[0];
  };


  /*
   *===========================================================================================================
  
  
  
  8888888 88888888888 8888888888 8888888b.         d8888 88888888888  .d88888b.  8888888b.   .d8888b.
    888       888     888        888   Y88b       d88888     888     d88P" "Y88b 888   Y88b d88P  Y88b
    888       888     888        888    888      d88P888     888     888     888 888    888 Y88b.
    888       888     8888888    888   d88P     d88P 888     888     888     888 888   d88P  "Y888b.
    888       888     888        8888888P"     d88P  888     888     888     888 8888888P"      "Y88b.
    888       888     888        888 T88b     d88P   888     888     888     888 888 T88b         "888
    888       888     888        888  T88b   d8888888888     888     Y88b. .d88P 888  T88b  Y88b  d88P
  8888888     888     8888888888 888   T88b d88P     888     888      "Y88888P"  888   T88b  "Y8888P"
  
  
  
   *===========================================================================================================
   */

  this.walk = function(me, handler) {
    var blockade_chr, cells, cells_per_line, content, content_txt, idx, last_page_idx, lines_per_page, page_idx, pcr, size, type, xy, _i, _len;
    cells = me.cells, cells_per_line = me.cells_per_line, lines_per_page = me.lines_per_page, blockade_chr = me.blockade_chr;
    last_page_idx = null;
    for (idx = _i = 0, _len = cells.length; _i < _len; idx = ++_i) {
      content = cells[idx];
      switch (type = TYPES.type_of(content)) {
        case 'jsundefined':
        case 'MINGKWAI/TYPESETTER/blockade':
          continue;
        case 'text':
          size = 1;
          content_txt = content;
          break;
        case 'MINGKWAI/TYPESETTER/block':
          size = content['size'];
          content_txt = content['content'];
          break;
        default:
          throw new Error("unknown type " + (rpr(type)));
      }
      xy = this.xy_from_idx(me, idx);
      pcr = this.pcr_from_xy(me, xy, size);
      page_idx = pcr[0];
      if (page_idx !== last_page_idx) {
        handler(null, ['page', page_idx]);
        last_page_idx = page_idx;
      }
      handler(null, ['block', xy, pcr, size, content_txt]);
    }
    handler(null, ['end']);
    return me;
  };


  /*
   *===========================================================================================================
  
  
  
   .d8888b.  88888888888 8888888b.  8888888888        d8888 888b     d888  .d8888b.
  d88P  Y88b     888     888   Y88b 888              d88888 8888b   d8888 d88P  Y88b
  Y88b.          888     888    888 888             d88P888 88888b.d88888 Y88b.
   "Y888b.       888     888   d88P 8888888        d88P 888 888Y88888P888  "Y888b.
      "Y88b.     888     8888888P"  888           d88P  888 888 Y888P 888     "Y88b.
        "888     888     888 T88b   888          d88P   888 888  Y8P  888       "888
  Y88b  d88P     888     888  T88b  888         d8888888888 888   "   888 Y88b  d88P
   "Y8888P"      888     888   T88b 8888888888 d88P     888 888       888  "Y8888P"
  
  
  
   *===========================================================================================================
   */

  this.$get_doc = function(handler) {
    if (handler == null) {
      handler = null;
    }
    if (handler != null) {
      return P1.remit((function(_this) {
        return function(event, send) {
          var doc, type;
          type = event[0], doc = event[1];
          if (type === 'doc') {
            handler(null, doc);
          }
          return send(event);
        };
      })(this));
    }
    return P1.remit((function(_this) {
      return function(event, send) {
        var doc, type;
        type = event[0], doc = event[1];
        if (type === 'doc') {
          return send(doc);
        }
      };
    })(this));
  };

  this.$show_doc = function() {
    return P1.remit((function(_this) {
      return function(event, send) {
        var doc, type;
        type = event[0], doc = event[1];
        if (type === 'doc') {
          log('\n' + _this.rpr(doc));
        }
        return send(event);
      };
    })(this));
  };

  this.create_readstream = function(me) {
    var R;
    R = P1.create_throughstream();
    R.pause();
    this.walk(me, function(error, event) {

      /* TAINT should respect buffering */

      /* TAINT how to deal with errors? */
      if (error) {
        throw error;
      }
      return R.write(event);
    });
    return R;
  };

  this.$assemble_html_events = function(settings) {

    /*
    ((畢昇發明活字印刷術))
    
    宋沈括著《夢溪筆談》卷十八記載
    ((版印書籍唐人尚未盛為之))
    自馮瀛王始印五經已後典籍皆為版本
    ((慶歷中，有布衣畢昇，又為活版。))
    其法用膠泥刻字，薄如錢唇，每字為一印，火燒令堅。先設一鐵版，其上以松脂臘和紙灰之類冒之。
    欲印則以一鐵範置鐵板上，乃密布字印。滿鐵範為一板，
    持就火煬之，藥稍鎔，則以一平板按其面，則字平如砥。
    ((若止印三、二本，未為簡易；若印數十百千本，則極為神速。))
    常作二鐵板，一板印刷，一板已自布字。此印者才畢，則第二板已具。
    更互用之，瞬息可就。每一字皆有數印，如之、也等字，每字有二十餘印，
    以備一板內有重複者。不用則以紙貼之，每韻為一貼，木格貯之。
    ((有奇字素無備者，旋刻之，以草火燒，瞬息可成。))
    不以木為之者，木理有疏密，沾水則高下不平，兼與藥相粘，不可取。
    不若燔土，用訖再火令藥熔，以手拂之，其印自落，
    殊不沾汙。昇死，其印為余群從所得，
    ((至今保藏。))
     */
    var advance, advance_later, advance_now, compress, get_size, is_first_block, is_first_event, me, next_odd_int, par_on_next_chr, sizes, start_size, stop_size;
    me = this.new_document(settings);
    is_first_event = true;
    is_first_block = true;
    par_on_next_chr = false;
    sizes = [];
    advance_later = (function(_this) {
      return function() {
        return par_on_next_chr = true;
      };
    })(this);
    advance_now = (function(_this) {
      return function() {
        return warn("advance and advance_column not used");
      };
    })(this);
    advance = (function(_this) {
      return function() {
        return warn("advance and advance_column not used");
      };
    })(this);
    get_size = (function(_this) {
      return function() {
        return sizes[sizes.length - 1];
      };
    })(this);
    next_odd_int = (function(_this) {
      return function(n) {
        return ((Math.floor(n / 2)) * 2) + 1;
      };
    })(this);
    stop_size = (function(_this) {
      return function() {
        sizes.pop();
        return start_size(get_size());
      };
    })(this);
    start_size = (function(_this) {
      return function(size) {
        _this.set_size(me, size);
        compress(me);
        return sizes.push(size);
      };
    })(this);
    compress = (function(_this) {
      return function() {
        var size;
        size = me.size;
        if (size !== 1 && size !== get_size()) {
          return _this.compress(me);
        }
      };
    })(this);
    return P1.remit((function(_this) {
      return function(event, send, end) {
        var attributes, chr, input, match, name, ok, size, tail, type, _i, _len, _ref;
        if (is_first_event) {
          start_size(1);
          send(['doc', me]);
          is_first_event = false;
        }
        if (event != null) {
          type = event[0], tail = 2 <= event.length ? __slice.call(event, 1) : [];
          ok = false;
          switch (type) {
            case 'text':
              advance_now();
              _ref = XNCHR.chrs_from_text(tail[0]);
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                chr = _ref[_i];
                if ((chr !== '\u3000') && /^\s*$/.test(chr)) {
                  continue;
                }
                _this.put(me, chr);
              }
              ok = true;
              break;
            case 'open-tag':
              name = tail[0], attributes = tail[1];
              switch (name) {
                case 'span':
                  if ((attributes['class'] != null) && ((match = attributes['class'].match(/^size-([0-9]+)$/)) != null)) {
                    size = parseInt(match[1], 10);
                  } else {
                    size = get_size();
                  }
                  start_size(size);
                  ok = true;
                  break;
                case 'p':
                case 'div':
                case 'h1':
                case 'h2':
                case 'h3':
                case 'h4':
                case 'h5':
                case 'h6':
                  compress();
                  if (!is_first_block) {
                    advance();
                  }
                  is_first_block = false;
                  ok = true;
              }
              break;
            case 'close-tag':
              switch (name = tail[0]) {
                case 'span':
                  stop_size();
                  ok = true;
              }
              break;
            case 'end':
              compress();
              ok = true;
          }
          if (!ok) {
            warn("ignored event: " + (rpr(event)));
          }
        }
        if (end != null) {
          input = _this.create_readstream(me).pipe(P1.remit(function(event, _) {
            send(event);
            if (event[0] === 'end') {
              return end();
            }
          }));
          return P1.resume(input);
        }
      };
    })(this));
  };

  this._new_mdx_parser = function() {
    var R, feature_set, settings;
    feature_set = 'full';
    settings = {
      html: true,
      xhtmlOut: false,
      breaks: false,
      langPrefix: 'language-',
      linkify: true,
      typographer: true,
      quotes: '“”‘’'
    };
    R = RMY.new_parser(feature_set, settings);
    RMY.use(R, RMY.get.examples.brackets({
      opener: '《',
      closer: '》',
      arity: 1,
      name: 'book-title'
    }));
    RMY.use(R, RMY.get.examples.brackets({
      opener: '(',
      closer: ')',
      arity: 1,
      name: 'size-1'
    }));
    RMY.use(R, RMY.get.examples.brackets({
      opener: '(',
      closer: ')',
      arity: 2,
      name: 'size-2'
    }));
    RMY.use(R, RMY.get.examples.brackets({
      opener: '(',
      closer: ')',
      arity: 3,
      name: 'size-3'
    }));
    RMY.use(R, RMY.get.examples.brackets({
      opener: '(',
      closer: ')',
      arity: 4,
      name: 'size-4'
    }));
    RMY.use(R, RMY.get.examples.xncrs());
    return R;
  };

  this._new_html_parser = function(stream) {
    var handlers, settings;
    settings = {
      xmlMode: false,
      decodeEntities: false,
      lowerCaseTags: false,
      lowerCaseAttributeNames: false,
      recognizeCDATA: true,
      recognizeSelfClosing: true
    };
    handlers = {
      onopentag: function(name, attributes) {
        return stream.write(['open-tag', name, attributes]);
      },
      ontext: function(text) {
        return stream.write(['text', text]);
      },
      onclosetag: function(name) {
        return stream.write(['close-tag', name]);
      },
      onend: function() {
        stream.write(['end']);
        return stream.end();
      },
      onerror: function(error) {
        return stream.error(error);
      }
    };
    return new Htmlparser(handlers, settings);
  };

  this.create_html_readstream_from_mdx_text = function(text, settings) {
    var R;
    if (settings != null) {
      throw new Error("settings currently unsupported");
    }
    R = P1.create_throughstream();
    R.pause();
    setImmediate((function(_this) {
      return function() {
        var html, html_parser, mdx_parser;
        mdx_parser = _this._new_mdx_parser();
        html = mdx_parser.render(text);
        info(html);
        html_parser = _this._new_html_parser(R);
        html_parser.write(html);
        return html_parser.end();
      };
    })(this));
    return R;
  };


  /*
   *===========================================================================================================
  
  
  
  888    888 8888888888 888      8888888b.  8888888888 8888888b.   .d8888b.
  888    888 888        888      888   Y88b 888        888   Y88b d88P  Y88b
  888    888 888        888      888    888 888        888    888 Y88b.
  8888888888 8888888    888      888   d88P 8888888    888   d88P  "Y888b.
  888    888 888        888      8888888P"  888        8888888P"      "Y88b.
  888    888 888        888      888        888        888 T88b         "888
  888    888 888        888      888        888        888  T88b  Y88b  d88P
  888    888 8888888888 88888888 888        8888888888 888   T88b  "Y8888P"
  
  
  
   *===========================================================================================================
   */

  this._get_grid_line_ys = function(me, n, module) {
    var y0;
    y0 = (Math.floor(n / module)) * module;
    return [y0, y0 + module - 1];
  };

  this._rpr_cell = function(me, cell) {
    var type;
    switch (type = TYPES.type_of(cell)) {
      case 'jsundefined':
        return me['free_cell_chr'];
      case 'MINGKWAI/TYPESETTER/blockade':
        return me['blockade_chr'];
      case 'MINGKWAI/TYPESETTER/block':
        return cell['content'];
      case 'text':
        return cell;
    }
    return rpr(cell);
  };

  this._get_remaining_line_length = function(me, size) {
    if (size == null) {
      size = null;
    }
    if (size == null) {
      size = me['size'];
    }
    return Math.floor((me['cells_per_line'] - this._get_x(me)) / size);
  };

  if (module.parent == null) {
    this.serve();
  }

}).call(this);
