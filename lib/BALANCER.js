// Generated by CoffeeScript 1.9.1
(function() {
  var LODASH, MATHJS, TRM, alert, badge, debug, echo, help, info, log, rpr, warn, whisper;

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'MINGKWAI/BALANCER';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  LODASH = require('LODASH');

  MATHJS = require('mathjs');

  this.prepare_items = function(cols) {
    var R, col, item, j, k, len, len1;
    R = [];
    for (j = 0, len = cols.length; j < len; j++) {
      col = cols[j];
      for (k = 0, len1 = col.length; k < len1; k++) {
        item = col[k];
        R.push(item);
      }
    }
    return R;
  };

  this.balance_columns = function(lines_per_page, col_count, items) {
    var R, best_R, col_idx, global_penalty, idx, item, item_count, j, k, l, len, len1, len2, max_penalty, min_penalty, o, over, penalties, penalty, ref, ref1, worst_col_idx, x;
    R = (function() {
      var j, ref, results;
      results = [];
      for (idx = j = 1, ref = col_count; 1 <= ref ? j <= ref : j >= ref; idx = 1 <= ref ? ++j : --j) {
        results.push([]);
      }
      return results;
    })();
    item_count = items.length;
    if (item_count <= col_count) {
      for (idx = j = 0, len = items.length; j < len; idx = ++j) {
        item = items[idx];
        R[idx].push(item);
      }
    } else {
      for (idx = k = 0, len1 = items.length; k < len1; idx = ++k) {
        item = items[idx];
        R[0].push(item);
      }
      if (col_count > 1) {
        min_penalty = Infinity;

        /* TAINT magic number */
        for (x = l = 1, ref = col_count * 50; 1 <= ref ? l <= ref : l >= ref; x = 1 <= ref ? ++l : --l) {
          ref1 = this.get_penalties(lines_per_page, col_count, items, R), over = ref1[0], global_penalty = ref1[1], penalties = ref1[2], R = ref1[3];
          if (global_penalty < min_penalty) {
            best_R = LODASH.cloneDeep(R);
            min_penalty = global_penalty;
          }
          if (over) {
            break;
          }
          max_penalty = -Infinity;
          worst_col_idx = 0;
          for (col_idx = o = 0, len2 = penalties.length; o < len2; col_idx = ++o) {
            penalty = penalties[col_idx];
            if (col_idx >= col_count - 1) {
              break;
            }
            if (penalty > max_penalty) {
              max_penalty = penalty;
              worst_col_idx = col_idx;
            }
          }
          if (R[worst_col_idx].length > 0) {
            this.move(R, worst_col_idx);
          }
        }
        R = best_R;
      }
    }
    return R;
  };

  this.move = function(cols, col_idx) {
    var col;
    if (!((0 <= col_idx && col_idx < cols.length - 1))) {
      throw new Error("illegal column index " + (rpr(col_idx)));
    }
    if (!((col = cols[col_idx]).length > 0)) {
      throw new Error("illegal empty column at index " + (rpr(col_idx)));
    }
    cols[col_idx + 1].push(cols[col_idx].shift());
    return cols;
  };

  this.get_penalties = function(lines_per_page, col_count, items, cols) {
    var col, col_idx, idx, item, item_idx, j, k, len, len1, length, lengths, mean_length, over, penalties, penalty;
    penalties = (function() {
      var j, ref, results;
      results = [];
      for (idx = j = 1, ref = col_count; 1 <= ref ? j <= ref : j >= ref; idx = 1 <= ref ? ++j : --j) {
        results.push(0);
      }
      return results;
    })();
    lengths = (function() {
      var j, ref, results;
      results = [];
      for (idx = j = 1, ref = col_count; 1 <= ref ? j <= ref : j >= ref; idx = 1 <= ref ? ++j : --j) {
        results.push(0);
      }
      return results;
    })();
    for (col_idx = j = 0, len = cols.length; j < len; col_idx = ++j) {
      col = cols[col_idx];
      for (item_idx = k = 0, len1 = col.length; k < len1; item_idx = ++k) {
        item = col[item_idx];
        lengths[col_idx] += item;
      }
      if (lengths[col_idx] > lines_per_page) {
        lengths[col_idx] = 1e6;
      }
    }
    over = lengths[col_count - 1] === 1e6;
    penalty = MATHJS.std(lengths);
    mean_length = MATHJS.mean(lengths);
    penalties = (function() {
      var l, len2, results;
      results = [];
      for (l = 0, len2 = lengths.length; l < len2; l++) {
        length = lengths[l];
        results.push(Math.abs(length - mean_length));
      }
      return results;
    })();
    return [over, penalty, penalties, cols];
  };

  this.demo = function() {
    var BNP, col_count, get_random_integer, i, idx, items, j, lines_per_page, m, n, ref, results, rnd, s0, s1;
    BNP = require('coffeenode-bitsnpieces');
    s0 = 2;
    s1 = 8;
    n = 3;
    m = 20;
    lines_per_page = 54;
    col_count = 3;
    get_random_integer = function(s0, s1) {
      return s0 + Math.floor(rnd() * (s1 - s0) + 0.5);
    };
    results = [];
    for (i = j = 1, ref = n; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
      rnd = BNP.get_rnd(i / 7);
      items = (function() {
        var k, ref1, results1;
        results1 = [];
        for (idx = k = 1, ref1 = m; 1 <= ref1 ? k <= ref1 : k >= ref1; idx = 1 <= ref1 ? ++k : --k) {
          results1.push(get_random_integer(s0, s1));
        }
        return results1;
      })();
      results.push(help(this.balance_columns(lines_per_page, col_count, items)));
    }
    return results;
  };

  if (module.parent == null) {
    this.demo();
  }

}).call(this);
