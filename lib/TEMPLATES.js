// Generated by CoffeeScript 1.8.0
(function() {
  var MKTS, STYLUS, TEACUP, TRM, alert, as_css, badge, css, debug, help, info, log, name_, njs_fs, njs_path, rpr, style_route, urge, warn, whisper;

  njs_path = require('path');

  njs_fs = require('fs');

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = '明快排字机/TEMPLATES';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  urge = TRM.get_logger('urge', badge);

  MKTS = require('./main');

  TEACUP = require('coffeenode-teacup');

  STYLUS = require('stylus');

  as_css = STYLUS.render.bind(STYLUS);

  style_route = njs_path.join(__dirname, '../public/mingkwai-typesetter.styl');

  css = as_css(njs_fs.readFileSync(style_route, {
    encoding: 'utf-8'
  }));

  for (name_ in TEACUP) {
    eval("" + name_ + " = TEACUP[ " + (rpr(name_)) + " ]");
  }

  this.layout = function() {
    return render((function(_this) {
      return function() {
        DOCTYPE(5);
        return HTML(function() {
          HEAD(function() {
            META({
              charset: 'utf-8'
            });
            TITLE('明快排字机');
            LINK({
              rel: 'shortcut icon',
              href: '/public/favicon.ico?v6'
            });
            return STYLE(css);
          });
          return BODY(function() {
            FORM("#controller", function() {
              BUTTON({
                name: 'record'
              }, '⏺');
              BUTTON({
                name: 'reset'
              }, '⏮');
              BUTTON({
                name: 'back'
              }, '⏴');
              BUTTON({
                name: 'pause'
              }, '⏸');
              BUTTON({
                name: 'play'
              }, '⏵');
              return BUTTON({
                name: 'next'
              }, '⏯');
            });
            BR();
            DIV("#table-container", function() {
              DIV("#doc-table-plain");
              return DIV("#doc-table-sized");
            });
            PRE("#json-display-doc", '');
            PRE("#json-display-cells", '');
            SCRIPT({
              src: 'http://code.jquery.com/jquery-1.11.1.js'
            });
            SCRIPT({
              src: '/socket.io/socket.io.js'
            });
            COFFEESCRIPT(function() {
              var socket;
              log = console.log.bind(console);
              socket = io();
              return ($('document')).ready(function() {
                ($('button')).on('click', function() {
                  var event_name, event_type, self;
                  self = $(this);
                  event_type = 'playback';
                  event_name = self.attr('name');
                  socket.emit(event_type, event_name);
                  return false;
                });
                socket.on('new-table', function(style, table_html) {
                  ($("#doc-table-" + style)).html(table_html);
                  return ($('html, body')).stop().animate({
                    scrollTop: ($('#bottom')).offset().top
                  }, 2000);
                });
                socket.on('change', function(observee, action, target_txt, name, value) {
                  log(observee, target_txt);
                  switch (observee) {
                    case 'cells':
                      return ($('#json-display-cells')).text(JSON.stringify(value));
                  }
                });
                ($(window)).on('beforeunload', function() {
                  return socket.close;
                });
                log('ok.');
                return null;
              });
            });
            return DIV('#bottom');
          });
        });
      };
    })(this));
  };

  this.doc_table = function(doc, style) {
    if (style == null) {
      style = 'plain';
    }
    return render((function(_this) {
      return function() {
        var auto_space_chr, block_space_chr, cells_per_line, free_cell_chr, x1, xc, y1, yc, _ref, _ref1;
        auto_space_chr = doc.auto_space_chr, block_space_chr = doc.block_space_chr, free_cell_chr = doc.free_cell_chr, cells_per_line = doc.cells_per_line;
        _ref = MKTS.get_next_xy(doc), x1 = _ref[0], y1 = _ref[1];
        _ref1 = MKTS.xy_from_idx(doc, doc['idx']), xc = _ref1[0], yc = _ref1[1];
        switch (style) {
          case 'plain':
            return TABLE('.doc-table', function() {
              var x, y, _i, _j, _k;
              TH();
              for (x = _i = 0; 0 <= cells_per_line ? _i < cells_per_line : _i > cells_per_line; x = 0 <= cells_per_line ? ++_i : --_i) {
                TH(x);
              }
              TH();
              for (y = _j = 0; 0 <= y1 ? _j <= y1 : _j >= y1; y = 0 <= y1 ? ++_j : --_j) {
                TR(function() {
                  var cell, cell_txt, clasz, _k;
                  TH(y);
                  for (x = _k = 0; 0 <= cells_per_line ? _k < cells_per_line : _k > cells_per_line; x = 0 <= cells_per_line ? ++_k : --_k) {
                    cell = MKTS._get(doc, [x, y], void 0);
                    cell_txt = MKTS._rpr_cell(doc, cell);
                    clasz = [];
                    if (x === xc) {
                      clasz.push('.this-col');
                    }
                    if (y === yc) {
                      clasz.push('.this-row');
                    }
                    if (x === xc && y === yc) {
                      clasz.push('.this-cell');
                    }
                    if (cell_txt === auto_space_chr) {
                      clasz.push('.auto-space');
                    }
                    if (cell_txt === block_space_chr) {
                      clasz.push('.block-space');
                    }
                    if (cell_txt === free_cell_chr) {
                      clasz.push('.free-cell');
                    }
                    TD(clasz.join(''), function() {
                      return cell_txt;
                    });
                  }
                  return TH(y);
                });
              }
              TH();
              for (x = _k = 0; 0 <= cells_per_line ? _k < cells_per_line : _k > cells_per_line; x = 0 <= cells_per_line ? ++_k : --_k) {
                TH(x);
              }
              return TH();
            });
          case 'sized':
            return TABLE('.doc-table', function() {
              var x, y, _i, _j, _k;
              TH();
              for (x = _i = 0; 0 <= cells_per_line ? _i < cells_per_line : _i > cells_per_line; x = 0 <= cells_per_line ? ++_i : --_i) {
                TH(x);
              }
              TH();
              for (y = _j = 0; 0 <= y1 ? _j <= y1 : _j >= y1; y = 0 <= y1 ? ++_j : --_j) {
                TR(function() {
                  var Q, cell, cell_txt, clasz, size, _k, _ref2;
                  TH(y);
                  for (x = _k = 0; 0 <= cells_per_line ? _k < cells_per_line : _k > cells_per_line; x = 0 <= cells_per_line ? ++_k : --_k) {
                    cell = MKTS._get(doc, [x, y], void 0);
                    cell_txt = MKTS._rpr_cell(doc, cell);
                    if (cell_txt === block_space_chr) {
                      continue;
                    }
                    size = (_ref2 = cell != null ? cell['size'] : void 0) != null ? _ref2 : 1;
                    Q = {};
                    if (size !== 1) {
                      Q['rowspan'] = Q['colspan'] = size;
                    }
                    clasz = [];
                    clasz.push(".size-" + size);
                    if (x === xc) {
                      clasz.push('.this-col');
                    }
                    if (y === yc) {
                      clasz.push('.this-row');
                    }
                    if (x === xc && y === yc) {
                      clasz.push('.this-cell');
                    }
                    if (cell_txt === auto_space_chr) {
                      clasz.push('.auto-space');
                    }
                    if (cell_txt === free_cell_chr) {
                      clasz.push('.free-cell');
                    }
                    TD(clasz.join(''), Q, function() {
                      return cell_txt;
                    });
                  }
                  return TH(y);
                });
              }
              TH();
              for (x = _k = 0; 0 <= cells_per_line ? _k < cells_per_line : _k > cells_per_line; x = 0 <= cells_per_line ? ++_k : --_k) {
                TH(x);
              }
              return TH();
            });
          default:
            throw new Error("unknown table style " + (rpr(style)));
        }
      };
    })(this));
  };

}).call(this);
