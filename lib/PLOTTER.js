// Generated by CoffeeScript 1.9.1
(function() {
  var GM, TEMP, TRM, TYPES, alert, badge, debug, echo, help, info, log, njs_fs, njs_path, options, rpr, warn, whisper,
    slice = [].slice;

  njs_fs = require('fs');

  njs_path = require('path');

  TYPES = require('coffeenode-types');

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'MINGKWAI/TYPESETTER';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  GM = require('gm');

  TEMP = (require('temp')).track();

  options = {
    'px-per-mm': 15,
    'width': 243,
    'height': 183 - 5,
    'colors': {
      'red': '86000b',
      'blue': '21247b',
      'black': '000000'
    }
  };

  this.new_image = function(settings, route) {
    var R, colors, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, substrate;
    R = {
      '~isa': 'MINGKWAI/PLOTTER/image'
    };
    R['route'] = (ref = route != null ? route : settings != null ? settings['route'] : void 0) != null ? ref : TEMP.path({
      suffix: '.png'
    });
    R['px-per-mm'] = (ref1 = settings != null ? settings['px-per-mm'] : void 0) != null ? ref1 : 15;
    R['width'] = (ref2 = settings != null ? settings['width'] : void 0) != null ? ref2 : 297 - 29 - 25;
    R['height'] = (ref3 = settings != null ? settings['height'] : void 0) != null ? ref3 : 210 - 11 - 12 - 5;
    R['colors'] = colors = [];
    R['tex'] = "\\includegraphics[width=" + R['width'] + "mm]{" + R['route'] + "}";
    R['stack'] = [];
    R['fill-color'] = null;
    R['line-color'] = null;
    R['line-width'] = null;
    R['line-caps'] = 'round';
    colors['red'] = (ref4 = settings != null ? (ref5 = settings['colors']) != null ? ref5['red'] : void 0 : void 0) != null ? ref4 : '#86000b';
    colors['blue'] = (ref6 = settings != null ? (ref7 = settings['colors']) != null ? ref7['blue'] : void 0 : void 0) != null ? ref6 : '#21247b';
    colors['black'] = (ref8 = settings != null ? (ref9 = settings['colors']) != null ? ref9['black'] : void 0 : void 0) != null ? ref8 : '#000000';
    substrate = GM(this.px_from_mm(R, R['width']), this.px_from_mm(R, R['height']), '#ffffff00');
    substrate.options({
      imageMagick: true
    });
    R['%self'] = substrate;
    return R;
  };

  this.push_style = function(me) {
    var i, len, name, ref, style;
    style = {};
    ref = ['fill-color', 'line-color', 'line-width', 'line-caps'];
    for (i = 0, len = ref.length; i < len; i++) {
      name = ref[i];
      style[name] = me[name];
    }
    me['stack'].push(style);
    return me;
  };

  this.pop_style = function(me) {
    var style;
    style = me['stack'].pop();
    this.fill(me, style['fill-color']);
    this.stroke(me, style['line-color'], style['line-width'], style['line-caps']);
    return me;
  };

  this.px_from_mm = function(me, d_mm) {
    return d_mm * me['px-per-mm'];
  };

  this.fill = function(me, color) {
    me['fill-color'] = color;
    me['%self'].fill(this.get_color(me, color));
    return me;
  };

  this.stroke = function(me, color, width, line_caps) {
    if (width == null) {
      width = 1;
    }
    if (line_caps == null) {
      line_caps = 'round';
    }
    me['line-color'] = color;
    me['line-width'] = width;
    me['line-caps'] = line_caps;
    me['%self'].stroke(this.get_color(me, color), this.px_from_mm(me, width));
    return me;
  };

  this.print = function(me, xy, text) {
    me['%self'].font('Helvetica');
    me['%self'].fontSize(me['px-per-mm'] * 3);
    me['%self'].drawText(xy[0], xy[1], text);
    return me;
  };

  this.move_xys = function() {
    var arity, d_xy, i, j, len, me, xy, xys;
    me = arguments[0], xys = 3 <= arguments.length ? slice.call(arguments, 1, i = arguments.length - 1) : (i = 1, []), d_xy = arguments[i++];
    arity = xys.length + (d_xy != null ? 1 : 0);
    if (!(arity >= 2)) {
      throw new Error("expected at least 2 arguments, got " + arity);
    }
    for (j = 0, len = xys.length; j < len; j++) {
      xy = xys[j];
      xy[0] += d_xy[0];
      xy[1] += d_xy[1];
    }
    return me;
  };

  this.get_color = function(me, color) {
    var ref, ref1;
    return (ref = (ref1 = me['colors']) != null ? ref1[color] : void 0) != null ? ref : color;
  };

  this.write_file = function(me, handler) {
    return me['%self'].write(me['route'], handler);
  };

  this.line = function(me, xy0, xy1) {
    var radius, style, x0, x1, y0, y1;
    x0 = this.px_from_mm(me, xy0[0]);
    y0 = this.px_from_mm(me, xy0[1]);
    x1 = this.px_from_mm(me, xy1[0]);
    y1 = this.px_from_mm(me, xy1[1]);
    me['%self'].drawLine(x0, y0, x1, y1);
    switch (style = me['line-caps']) {
      case 'round':
        this.push_style(me);
        radius = me['line-width'] / 2;
        this.fill(me, me['line-color']);
        this.stroke(me, 'transparent', 0);
        this.circle(me, xy0, radius);
        this.circle(me, xy1, radius);
        this.pop_style(me);
        break;
      default:
        throw new Error("unknown line-caps style " + (rpr(style)));
    }
    return me;
  };

  this.circle = function(me, xy0, r) {
    var x0, x1, y0, y1;
    x0 = this.px_from_mm(me, xy0[0]);
    y0 = this.px_from_mm(me, xy0[1]);
    x1 = x0 + this.px_from_mm(me, r);
    y1 = y0;
    me['%self'].drawCircle(x0, y0, x1, y1);
    return me;
  };

  this.main = function(route, handler) {
    var PLOTTER, img, settings, substrate, xy0, xy1;
    PLOTTER = this;
    settings = null;
    img = PLOTTER.new_image(settings, route);
    xy0 = [10, 10];
    xy1 = [24, 18];
    substrate = img['%self'];
    PLOTTER.fill(img, 'white');
    PLOTTER.fill(img, 'transparent');
    PLOTTER.stroke(img, 'red', 5);
    PLOTTER.line(img, xy0, xy1);
    PLOTTER.line(img, [20, 20], [30, 30]);
    PLOTTER.write_file(img, handler);
    info(img['tex']);
    return null;
  };

  if (module.parent == null) {
    this.main('/tmp/img.png', function(error) {
      if (error != null) {
        throw error;
      }
      return help('ok');
    });
  }

}).call(this);
